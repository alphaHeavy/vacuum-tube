#include <Cmm.h>

// Serializze_getInfoTable :: Any -> State# s -> (# State# s, Addr# #)
Serializze_getInfoTable (P_ a)
{
  return (%GET_STD_INFO(UNTAG(a)));
}

// Serializze_allocateClosure :: Addr# -> State# s -> (# State# s, Any, Word#, Word# #)
Serializze_allocateClosure (W_ info)
{
  W_ bytes, ptrs, nptrs;

  ptrs = TO_W_(%INFO_PTRS(info));
  nptrs = TO_W_(%INFO_NPTRS(info));
  bytes = SIZEOF_StgHeader + WDS(ptrs) + WDS(nptrs);

  HP_CHK_GEN(bytes);

  P_ val;
  val = Hp + WDS(1);
  Hp = Hp + bytes;

  SET_HDR(val, info+SIZEOF_StgInfoTable, CCCS);

  W_ i;
  i = 0;

loop1:
  if (i < ptrs)
  {
    StgClosure_payload(val, i) = base_GHCziErr_undefined_closure;
    i = i + 1;
    goto loop1;
  }

loop2:
  if (i < (ptrs + nptrs))
  {
    StgClosure_payload(val, i) = 0;
    i = i + 1;
    goto loop2;
  }

  return (val, ptrs, nptrs);
}

// Serializze_setPtr :: Addr# -> Word# -> Addr# -> State# s -> (# State# s #)
Serializze_setPtr (P_ a, W_ i, P_ v)
{
  StgClosure_payload(a, i) = v;
  return ();
}

// Serializze_setNPtr :: Addr# -> Word# -> Word# -> State# s -> (# State# s #)
Serializze_setNPtr (P_ a, W_ i, W_ v)
{
  StgClosure_payload(a, i) = v;
  return ();
}

// Serializze_dumpArray :: Addr# -> Word# -> Word# -> Word# -> EncodedState -> (# EncodedStates #)
Serializze_dumpArray (P_ a, W_ clos, W_ info, W_ type, P_ st)
{
  // Serialize.pushTag :: Word# -> Addr# -> Addr# -> EncodedState -> EncodedState
  (P_ stx) = call %ENTRY_CODE(Serializze_pushTag_info) (Serializze_pushTag_info, type, info, clos, st);

  // // // Serialize.yieldArrWords :: Word# -> ByteArray# -> EncodedState -> EncodedState
  (P_ sty) = call %ENTRY_CODE(Serializze_yieldArrWords_info) (Serializze_yieldArrWords_info, 0, clos, stx);

  // popTag :: EncodedState -> EncodedState
  jump %ENTRY_CODE(Serializze_popTag_info) (Serializze_popTag_info, sty);
}

Serializze_dumpClosure (P_ a, W_ clos, W_ info, W_ type, P_ st)
{
  // Serialize.pushTag :: Word# -> Addr# -> Addr# -> EncodedState -> EncodedState
  (P_ stx) = call %ENTRY_CODE(Serializze_pushTag_info) (Serializze_pushTag_info, type, info, clos, st);

  W_ ptrs;
  ptrs = TO_W_(%INFO_PTRS(info));
  jump Serializze_dumpPtrs (clos, 0, ptrs, stx);
}

// Entry point in the Cmm side to walk the value graph pointed to from a
// while folding st over each value and their respective payloads
//
// Serializze_encodeObject :: a -> EncodedState -> EncodedState
Serializze_encodeObject (P_ a, P_ st)
{
  W_ clos, info, type;
  clos = UNTAG(a);
  info = %GET_STD_INFO(clos);
  type = TO_W_(%INFO_TYPE(info));

  switch [INVALID_OBJECT .. N_CLOSURE_TYPES] (type)
  {
    // specialization for ByteArray#
    case ARR_WORDS:
    {
      jump Serializze_dumpArray (a, clos, info, type, st);
    }

    // @TODO: implement, frozen mutable arrays are ok
    case MUT_ARR_PTRS_FROZEN0, MUT_ARR_PTRS_FROZEN:
      goto FAIL;

    // but not after they're thawed
    case MUT_ARR_PTRS_CLEAN, MUT_ARR_PTRS_DIRTY:
      goto FAIL;

    // we've stumbled upon thread related bits
    case TSO, STACK, UPDATE_FRAME, CATCH_FRAME, UNDERFLOW_FRAME, STOP_FRAME:
      goto FAIL;

    // Call a helper function to block on the blackhole
    case BLACKHOLE, WHITEHOLE:
      goto FAIL;

    // MVars
    case MUT_VAR_CLEAN, MUT_VAR_DIRTY:
      goto FAIL;

    // STM support
    case TREC_CHUNK, ATOMICALLY_FRAME, CATCH_RETRY_FRAME, CATCH_STM_FRAME:
      goto FAIL;

    // pointer types
    case WEAK, PRIM, MUT_PRIM:
      goto FAIL;

    // @TODO: unsure about these ... i'm guessing we need to handle them
    case RET_BCO, RET_SMALL, RET_BIG, RET_FUN, AP_STACK:
      goto FAIL;

    case CONSTR, CONSTR_1_0, CONSTR_0_1, CONSTR_2_0, CONSTR_1_1, CONSTR_0_2, CONSTR_STATIC, CONSTR_NOCAF_STATIC,
         FUN, FUN_1_0, FUN_0_1, FUN_2_0, FUN_1_1, FUN_0_2, FUN_STATIC,
         THUNK, THUNK_1_0, THUNK_0_1, THUNK_2_0, THUNK_1_1, THUNK_0_2, THUNK_STATIC, THUNK_SELECTOR,
         IND, IND_PERM, IND_STATIC,
         AP, PAP:
    {
      jump Serializze_dumpClosure (a, clos, info, type, st);
    }

    default:
    {
FAIL:
      // Serialize.unsupportedTag :: Word# -> Addr# -> Addr# -> EncodedState -> EncodedState
      jump %ENTRY_CODE(Serializze_unsupportedTag_info) (Serializze_unsupportedTag_info, type, info, clos, st);
    }
  }
}

// Call yieldPtr for each pointer payload then call dumpNPtrs for the rest
Serializze_dumpPtrs (P_ clos, W_ p, W_ lim, P_ st)
{
  if (p < lim)
  {
    // yieldPtr :: Word# -> Addr# -> EncodedState -> EncodedState
    (P_ stx) = call %ENTRY_CODE(Serializze_yieldPtr_info) (Serializze_yieldPtr_info, p, UNTAG(StgClosure_payload(clos, p)), st);
    jump Serializze_dumpPtrs (clos, p + 1, lim, stx);
  }
  else
  {
    W_ info, nptrs;
    info = %GET_STD_INFO(clos);
    nptrs = TO_W_(%INFO_NPTRS(info));
    jump Serializze_dumpNPtrs (clos, p, lim + nptrs, st);
  }
}

// Call yieldNPtr for each non-pointer payload then pop the current value off
// the serialization stack, continuing on our walk
Serializze_dumpNPtrs (P_ clos, W_ p, W_ lim, P_ st)
{
  if (p < lim)
  {
    // yieldNPtr :: Word# -> Word# -> EncodedState -> EncodedState
    (P_ stx) = call %ENTRY_CODE(Serializze_yieldNPtr_info) (Serializze_yieldNPtr_info, p, StgClosure_payload(clos, p), st);
    jump Serializze_dumpNPtrs (clos, p + 1, lim, stx);
  }
  else
  {
    // popTag :: EncodedState -> EncodedState
    jump %ENTRY_CODE(Serializze_popTag_info) (Serializze_popTag_info, st);
  }
}
