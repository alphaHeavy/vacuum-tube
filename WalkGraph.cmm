#include <Cmm.h>

// Entry point in the Cmm side to walk the value graph pointed to from a
// while folding st over each value and their respective payloads
//
// Serializze_encodeObject :: a -> EncodedState -> EncodedState
Serializze_encodeObject (P_ a, P_ st)
{
  W_ clos, info, type;
  clos = UNTAG(a);
  info = %GET_STD_INFO(clos);
  type = TO_W_(%INFO_TYPE(info));

  // Serialize.pushTag :: Word# -> Addr# -> Addr# -> EncodedState -> EncodedState
  (P_ stx) = call %ENTRY_CODE(Serializze_pushTag_info) (Serializze_pushTag_info, type, info, clos, st);

  switch [INVALID_OBJECT .. N_CLOSURE_TYPES] (type)
  {
    // specialization for ByteArray#
    case ARR_WORDS:
    {
      // Serialize.yieldArrWords :: Word# -> ByteArray# -> EncodedState -> EncodedState
      jump %ENTRY_CODE(Serializze_yieldArrWords_info) (Serializze_yieldArrWords_info, 0, clos, stx);
    }

    default:
    {
      W_ ptrs;
      ptrs = TO_W_(%INFO_PTRS(info));
      jump Serializze_dumpPtrs (clos, 0, ptrs, stx);
    }
  }
}

// Call yieldPtr for each pointer payload then call dumpNPtrs for the rest
Serializze_dumpPtrs (P_ clos, W_ p, W_ lim, P_ st)
{
  if (p < lim)
  {
    // yieldPtr :: Word# -> Addr# -> EncodedState -> EncodedState
    (P_ stx) = call %ENTRY_CODE(Serializze_yieldPtr_info) (Serializze_yieldPtr_info, p, UNTAG(StgClosure_payload(clos, p)), st);
    jump Serializze_dumpPtrs (clos, p + 1, lim, stx);
  }
  else
  {
    W_ info, nptrs;
    info = %GET_STD_INFO(clos);
    nptrs = TO_W_(%INFO_NPTRS(info));
    jump Serializze_dumpNPtrs (clos, p, lim + nptrs, st);
  }
}

// Call yieldNPtr for each non-pointer payload then pop the current value off
// the serialization stack, continuing on our walk
Serializze_dumpNPtrs (P_ clos, W_ p, W_ lim, P_ st)
{
  if (p < lim)
  {
    // yieldNPtr :: Word# -> Word# -> EncodedState -> EncodedState
    (P_ stx) = call %ENTRY_CODE(Serializze_yieldNPtr_info) (Serializze_yieldNPtr_info, p, StgClosure_payload(clos, p), st);
    jump Serializze_dumpNPtrs (clos, p + 1, lim, stx);
  }
  else
  {
    // popTag :: EncodedState -> EncodedState
    jump %ENTRY_CODE(Serializze_popTag_info) (Serializze_popTag_info, st);
  }
}
