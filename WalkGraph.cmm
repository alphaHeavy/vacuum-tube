#include <Cmm.h>

Serializze_encodeObject (P_ a, P_ st)
{
  W_ clos, info, type;
  clos = UNTAG(a);
  info = %GET_STD_INFO(clos);
  type = TO_W_(%INFO_TYPE(info));
  (P_ stx) = call %ENTRY_CODE(Serializze_pushTag_info) (Serializze_pushTag_info, type, clos, st);

  switch [INVALID_OBJECT .. N_CLOSURE_TYPES] (type)
  {
    case FUN_STATIC:
    {
      W_ finfo;
      finfo = %FUN_INFO(info);
      jump %ENTRY_CODE(Serializze_popTag_info) (Serializze_popTag_info, stx);
    }

    default:
    {
      W_ ptrs;
      ptrs = TO_W_(%INFO_PTRS(info));
      jump Serializze_dumpPtrs (clos, 0, ptrs, stx);
    }
  }
}

Serializze_dumpPtrs (P_ clos, W_ p, W_ lim, P_ st)
{
  if (p < lim)
  {
    (P_ stx) = call %ENTRY_CODE(Serializze_yieldPtr_info) (Serializze_yieldPtr_info, UNTAG(StgClosure_payload(clos, p)), st);
    jump Serializze_dumpPtrs (clos, p + 1, lim, stx);
  }
  else
  {
    W_ info, nptrs;
    info = %GET_STD_INFO(clos);
    nptrs = TO_W_(%INFO_NPTRS(info));
    jump Serializze_dumpNPtrs (clos, p, lim + nptrs, st);
  }
}

Serializze_dumpNPtrs (P_ clos, W_ p, W_ lim, P_ st)
{
  if (p < lim)
  {
    (P_ stx) = call %ENTRY_CODE(Serializze_yieldNPtr_info) (Serializze_yieldNPtr_info, StgClosure_payload(clos, p), st);
    jump Serializze_dumpNPtrs (clos, p + 1, lim, stx);
  }
  else
  {
    jump %ENTRY_CODE(Serializze_popTag_info) (Serializze_popTag_info, st);
  }
}
