#include <Cmm.h>

// WalkGraph_getInfoTable :: Any -> State# s -> (# State# s, Addr# #)
WalkGraph_getInfoTable (P_ a)
{
  return (%GET_STD_INFO(UNTAG(a)));
}

// WalkGraph_allocateClosure :: Addr# -> Word# -> Word# -> State# s -> (# State# s, Any, Word#, Word# #)
WalkGraph_allocateClosure (W_ info, W_ ptrs, W_ nptrs)
{
  W_ bytes;

  bytes = SIZEOF_StgHeader + WDS(ptrs) + WDS(nptrs);

  HP_CHK_GEN(bytes);

  P_ val;
  val = Hp + WDS(1);
  Hp = Hp + bytes;

  SET_HDR(val, info+SIZEOF_StgInfoTable, CCCS);

  W_ i;
  i = 0;

loop1:
  if (i < ptrs)
  {
    StgClosure_payload(val, i) = base_GHCziErr_undefined_closure;
    i = i + 1;
    goto loop1;
  }

loop2:
  if (i < (ptrs + nptrs))
  {
    StgClosure_payload(val, i) = 0;
    i = i + 1;
    goto loop2;
  }

  return (val);
}

// WalkGraph_setPtr :: Addr# -> Word# -> Addr# -> State# s -> (# State# s #)
WalkGraph_setPtr (P_ a, W_ i, P_ v)
{
  OVERWRITING_CLOSURE(a);
  StgClosure_payload(a, i) = v;
  return ();
}

// WalkGraph_indirectByteArray :: Addr# -> ByteArray# -> State# s -> (# State# s #)
WalkGraph_indirectByteArray (P_ a, P_ v)
{
  OVERWRITING_CLOSURE(a);
  SET_INFO(a, stg_IND_info);
  StgInd_indirectee(a) = v;
  return ();
}

// WalkGraph_setNPtr :: Addr# -> Word# -> Word# -> State# s -> (# State# s #)
WalkGraph_setNPtr (P_ a, W_ i, W_ v)
{
  StgClosure_payload(a, i) = v;
  return ();
}

// WalkGraph_dumpArray :: Addr# -> Word# -> Word# -> Word# -> EncodedState -> (# EncodedStates #)
WalkGraph_dumpArray (P_ a, W_ clos, W_ info, W_ type, P_ st)
{
  // Serialize.pushTag :: Word# -> Addr# -> Addr# -> EncodedState -> EncodedState
  (P_ stx) = call %ENTRY_CODE(Serializze_pushTag_info) (Serializze_pushTag_info, type, info, 0, 0, clos, st);

  // // // Serialize.yieldArrWords :: Word# -> ByteArray# -> EncodedState -> EncodedState
  (P_ sty) = call %ENTRY_CODE(Serializze_yieldArrWords_info) (Serializze_yieldArrWords_info, 0, clos, stx);

  // popTag :: EncodedState -> EncodedState
  jump %ENTRY_CODE(Serializze_popTag_info) (Serializze_popTag_info, sty);
}

WalkGraph_dumpClosure (P_ a, W_ clos, W_ info, W_ type, P_ st)
{
  W_ ptrs, nptrs;
  ptrs = TO_W_(%INFO_PTRS(info));
  nptrs = TO_W_(%INFO_NPTRS(info));

  // Serialize.pushTag :: Word# -> Addr# -> Addr# -> EncodedState -> EncodedState
  (P_ stx) = call %ENTRY_CODE(Serializze_pushTag_info) (Serializze_pushTag_info, type, info, ptrs, nptrs, clos, st);

  W_ ptrs;
  ptrs = TO_W_(%INFO_PTRS(info));
  jump WalkGraph_dumpPtrs (clos, 0, ptrs, stx);
}

// WalkGraph_dumpIndirection :: Addr# -> Word# -> Word# -> Word# -> EncodedState -> (# EncodedStates #)
WalkGraph_dumpIndirection (P_ a, W_ clos, W_ info, W_ type, P_ st)
{
  // Serialize.pushTag :: Word# -> Addr# -> Addr# -> EncodedState -> EncodedState
  (P_ stx) = call %ENTRY_CODE(Serializze_pushTag_info) (Serializze_pushTag_info, type, info, 1, 0, clos, st);

  // // // Serialize.yieldArrWords :: Word# -> ByteArray# -> EncodedState -> EncodedState
  (P_ sty) = call %ENTRY_CODE(Serializze_yieldPtr_info) (Serializze_yieldPtr_info, 0, UNTAG(StgInd_indirectee(clos)), stx);

  // popTag :: EncodedState -> EncodedState
  jump %ENTRY_CODE(Serializze_popTag_info) (Serializze_popTag_info, sty);
}

// WalkGraph_dumpStatic :: Addr# -> Word# -> Word# -> Word# -> EncodedState -> (# EncodedStates #)
WalkGraph_dumpStatic (P_ a, W_ clos, W_ info, W_ type, P_ st)
{
  // Serialize.pushStatic :: Word# -> Addr# -> Addr# -> EncodedState -> EncodedState
  (P_ stx) = call %ENTRY_CODE(Serializze_pushStatic_info) (Serializze_pushTag_info, clos, st);

  // popTag :: EncodedState -> EncodedState
  jump %ENTRY_CODE(Serializze_popTag_info) (Serializze_popTag_info, stx);
}

// Entry point in the Cmm side to walk the value graph pointed to from a
// while folding st over each value and their respective payloads
//
// WalkGraph_encodeObject :: a -> EncodedState -> EncodedState
WalkGraph_encodeObject (P_ a, P_ st)
{
AGAIN:
  W_ clos, info, type;
  clos = UNTAG(a);
  if (clos == 0)
  {
    return (st);
  }

  info = %GET_STD_INFO(clos);
  type = TO_W_(%INFO_TYPE(info));

  switch [INVALID_OBJECT .. N_CLOSURE_TYPES] (type)
  {
    // specialization for ByteArray#
    case ARR_WORDS:
    {
      jump WalkGraph_dumpArray (a, clos, info, type, st);
    }

    // @TODO: implement, frozen mutable arrays are ok
    case MUT_ARR_PTRS_FROZEN0, MUT_ARR_PTRS_FROZEN:
      goto FAIL;

    // but not after they're thawed
    case MUT_ARR_PTRS_CLEAN, MUT_ARR_PTRS_DIRTY:
      goto FAIL;

    // we've stumbled upon thread related bits
    case TSO, STACK, UPDATE_FRAME, CATCH_FRAME, UNDERFLOW_FRAME, STOP_FRAME:
      goto FAIL;

    // MVars
    case MUT_VAR_CLEAN, MUT_VAR_DIRTY:
      goto FAIL;

    // STM support
    case TREC_CHUNK, ATOMICALLY_FRAME, CATCH_RETRY_FRAME, CATCH_STM_FRAME:
      goto FAIL;

    // pointer types
    case WEAK, PRIM, MUT_PRIM:
      goto FAIL;

    // @TODO: unsure about these ... i'm guessing we need to handle them
    case RET_BCO, RET_SMALL, RET_BIG, RET_FUN, AP_STACK:
      goto FAIL;

    case BLACKHOLE, WHITEHOLE, IND, IND_PERM:
    {
      jump WalkGraph_dumpIndirection (a, clos, info, type, st);
    }

    case IND_STATIC, CONSTR_STATIC, CONSTR_NOCAF_STATIC, FUN_STATIC, THUNK_STATIC:
    {
      jump WalkGraph_dumpStatic (a, clos, info, type, st);
    }

    case CONSTR, CONSTR_1_0, CONSTR_0_1, CONSTR_2_0, CONSTR_1_1, CONSTR_0_2,
         FUN, FUN_1_0, FUN_0_1, FUN_2_0, FUN_1_1, FUN_0_2,
         THUNK, THUNK_1_0, THUNK_0_1, THUNK_2_0, THUNK_1_1, THUNK_0_2, THUNK_SELECTOR,
         AP, PAP:
    {
      jump WalkGraph_dumpClosure (a, clos, info, type, st);
    }

    default:
    {
FAIL:
      // Serialize.unsupportedTag :: Word# -> Addr# -> Addr# -> EncodedState -> EncodedState
      jump %ENTRY_CODE(Serializze_unsupportedTag_info) (Serializze_unsupportedTag_info, type, info, clos, st);
    }
  }
}

// Call yieldPtr for each pointer payload then call dumpNPtrs for the rest
WalkGraph_dumpPtrs (P_ clos, W_ p, W_ lim, P_ st)
{
  if (p < lim)
  {
    // yieldPtr :: Word# -> Addr# -> EncodedState -> EncodedState
    (P_ stx) = call %ENTRY_CODE(Serializze_yieldPtr_info) (Serializze_yieldPtr_info, p, UNTAG(StgClosure_payload(clos, p)), st);
    jump WalkGraph_dumpPtrs (clos, p + 1, lim, stx);
  }
  else
  {
    W_ info, nptrs;
    info = %GET_STD_INFO(clos);
    nptrs = TO_W_(%INFO_NPTRS(info));
    jump WalkGraph_dumpNPtrs (clos, p, lim + nptrs, st);
  }
}

// Call yieldNPtr for each non-pointer payload then pop the current value off
// the serialization stack, continuing on our walk
WalkGraph_dumpNPtrs (P_ clos, W_ p, W_ lim, P_ st)
{
  if (p < lim)
  {
    // yieldNPtr :: Word# -> Word# -> EncodedState -> EncodedState
    (P_ stx) = call %ENTRY_CODE(Serializze_yieldNPtr_info) (Serializze_yieldNPtr_info, p, StgClosure_payload(clos, p), st);
    jump WalkGraph_dumpNPtrs (clos, p + 1, lim, stx);
  }
  else
  {
    // popTag :: EncodedState -> EncodedState
    jump %ENTRY_CODE(Serializze_popTag_info) (Serializze_popTag_info, st);
  }
}
